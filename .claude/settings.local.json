{
  "permissions": {
    "allow": [
      "Bash(python -c \"\nimport sys\n\n# Leggi il file\nwith open(''analisi_trafficonewfct_profsari.py'', ''r'', encoding=''utf-8'') as f:\n    content = f.read()\n\n# Trova la posizione dove inserire la funzione helper (prima di _forecast_intraday_dinamico)\ninsert_pos = content.find(''def _forecast_intraday_dinamico(df, giorni_forecast=28, produce_outputs=False):'')\n\nif insert_pos == -1:\n    print(''ERRORE: funzione non trovata'')\n    sys.exit(1)\n\n# Codice della funzione helper\nhelper_func = ''''''def _process_single_fascia_intraday(args):\n    \"\"\"\"\"\"Helper per processare una singola fascia oraria in parallelo.\"\"\"\"\"\"\n    fascia, df_fascia_subset, future_dates, giorni_forecast = args\n    \n    try:\n        from statsmodels.tsa.holtwinters import ExponentialSmoothing\n        \n        forecast_results = []\n        \n        if len(df_fascia_subset) < 14:\n            # Dati insufficienti, usa media storica\n            media_per_dow = df_fascia_subset.groupby(''DOW'')[''OFFERTO''].mean().to_dict()\n            for future_date in future_dates:\n                dow = future_date.dayofweek\n                forecast_val = media_per_dow.get(dow, df_fascia_subset[''OFFERTO''].mean())\n                forecast_results.append({\n                    ''DATA'': future_date,\n                    ''FASCIA'': fascia,\n                    ''MINUTI'': df_fascia_subset[''MINUTI''].iloc[0] if len(df_fascia_subset) > 0 else 0,\n                    ''GG_SETT'': [''lun'',''mar'',''mer'',''gio'',''ven'',''sab'',''dom''][dow],\n                    ''FORECAST'': max(0, forecast_val)\n                })\n            return forecast_results\n        \n        # Crea serie temporale per questa fascia\n        ts = df_fascia_subset.groupby(''DATA'')[''OFFERTO''].mean().sort_index()\n        ts = ts.asfreq(''D'', fill_value=0)\n        \n        try:\n            # Modello Holt-Winters con stagionalita settimanale\n            model = ExponentialSmoothing(\n                ts.values,\n                seasonal_periods=7,\n                trend=''add'',\n                seasonal=''add'',\n                initialization_method=''estimated''\n            )\n            fit = model.fit()\n            forecast_vals = fit.forecast(steps=giorni_forecast)\n        \n        except Exception:\n            # Fallback: usa media mobile con pattern settimanale\n            media_per_dow = df_fascia_subset.groupby(''DOW'')[''OFFERTO''].mean().to_dict()\n            base = ts.tail(7).mean()\n            forecast_vals = []\n            for i, future_date in enumerate(future_dates):\n                dow = future_date.dayofweek\n                dow_factor = media_per_dow.get(dow, base) / base if base > 0 else 1.0\n                forecast_vals.append(base * dow_factor)\n        \n        # Salva risultati\n        for i, future_date in enumerate(future_dates):\n            dow = future_date.dayofweek\n            forecast_results.append({\n                ''DATA'': future_date,\n                ''FASCIA'': fascia,\n                ''MINUTI'': df_fascia_subset[''MINUTI''].iloc[0] if len(df_fascia_subset) > 0 else 0,\n                ''GG_SETT'': [''lun'',''mar'',''mer'',''gio'',''ven'',''sab'',''dom''][dow],\n                ''FORECAST'': max(0, forecast_vals[i] if i < len(forecast_vals) else 0)\n            })\n        \n        return forecast_results\n    \n    except Exception as exc:\n        # In caso di errore, ritorna lista vuota\n        return []\n\n\n''''''\n\n# Inserisci la funzione helper prima di _forecast_intraday_dinamico\nnew_content = content[:insert_pos] + helper_func + content[insert_pos:]\n\n# Salva il file\nwith open(''analisi_trafficonewfct_profsari.py'', ''w'', encoding=''utf-8'') as f:\n    f.write(new_content)\n\nprint(''OK: Funzione helper aggiunta'')\n\")"
    ]
  }
}
